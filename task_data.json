{
  "pr_description": "\n# EventFD Semaphore Enhancement\n\nThe current implementation of the `Semaphore` class in `quick2wire/eventfd.py` needs to be improved to better support integration with event polling mechanisms. Your task is to:\n\n1. Modify the `Semaphore` class to support both blocking and non-blocking modes\n2. Update the signaling mechanism to be more efficient\n3. Replace the `ack` method with a new `receive` method that:\n   - Returns a boolean indicating whether a signal was received\n   - Properly handles non-blocking operations when no signals are available\n\nThe tests verify that the semaphore works correctly with epoll in both blocking and non-blocking modes, and that signals can be properly sent and received.\n",
  "repo_name": "romilly/quick2wire-python-api",
  "before_sha": "1ba52e4757a8c7b159ccd646f453017f6e89ef7e",
  "after_sha": "ab4c1b58fc5e639db227bdd82083cb8eac9f8543",
  "reference_implementation_diff": "diff --git a/quick2wire/eventfd.py b/quick2wire/eventfd.py\nindex 4afcd7f..4783f00 100644\n--- a/quick2wire/eventfd.py\n+++ b/quick2wire/eventfd.py\n@@ -1,6 +1,9 @@\n \n from ctypes import *\n import os\n+import errno\n+\n+# From sys/eventfd.h\n \n EFD_SEMAPHORE = 1\n EFD_CLOEXEC = 0o2000000\n@@ -10,14 +13,13 @@ _libc = cdll.LoadLibrary(None)\n \n eventfd_t = c_uint64\n eventfd = _libc.eventfd\n-eventfd_read = _libc.eventfd_read\n-eventfd_write = _libc.eventfd_write\n \n \n class Semaphore:\n     \"\"\"A Semaphore implemented with eventfd so that it can be used with epoll.\"\"\"\n-    def __init__(self):\n-        self._fd = eventfd(0, EFD_SEMAPHORE)\n+    \n+    def __init__(self, blocking=True):\n+        self._fd = eventfd(0, EFD_SEMAPHORE|((not blocking)*EFD_NONBLOCK))\n     \n     def close(self):\n         os.close(self._fd)\n@@ -25,10 +27,15 @@ class Semaphore:\n     def fileno(self):\n         return self._fd\n     \n-    def signal(self, n=1):\n-        eventfd_write(self._fd, c_int64(n))\n+    def signal(self):\n+        return os.write(self._fd, eventfd_t(1))\n     \n-    def ack(self, n=1):\n-        buf = c_int64()\n-        eventfd_read(self._fd, buf)\n-        \n+    def receive(self):\n+        try:\n+            os.read(self._fd, 8)\n+            return True\n+        except OSError as e:\n+            if e.errno == errno.EAGAIN:\n+                return False\n+            else:\n+                raise\n",
  "diff_1": "diff --git a/quick2wire/eventfd.py b/quick2wire/eventfd.py\nindex 4afcd7f..7f4e68b 100644\n--- a/quick2wire/eventfd.py\n+++ b/quick2wire/eventfd.py\n@@ -1,6 +1,7 @@\n \n from ctypes import *\n import os\n+import errno\n \n EFD_SEMAPHORE = 1\n EFD_CLOEXEC = 0o2000000\n@@ -13,11 +14,21 @@ eventfd = _libc.eventfd\n eventfd_read = _libc.eventfd_read\n eventfd_write = _libc.eventfd_write\n \n+# Fix function signatures\n+eventfd_read.argtypes = [c_int, POINTER(c_uint64)]\n+eventfd_read.restype = c_int\n+\n+eventfd_write.argtypes = [c_int, c_uint64]  \n+eventfd_write.restype = c_int\n+\n \n class Semaphore:\n     \"\"\"A Semaphore implemented with eventfd so that it can be used with epoll.\"\"\"\n-    def __init__(self):\n-        self._fd = eventfd(0, EFD_SEMAPHORE)\n+    def __init__(self, blocking=True):\n+        flags = EFD_SEMAPHORE\n+        if not blocking:\n+            flags = flags | EFD_NONBLOCK\n+        self._fd = eventfd(0, flags)\n     \n     def close(self):\n         os.close(self._fd)\n@@ -26,9 +37,20 @@ class Semaphore:\n         return self._fd\n     \n     def signal(self, n=1):\n-        eventfd_write(self._fd, c_int64(n))\n+        result = eventfd_write(self._fd, n)\n+        if result != 0:\n+            raise OSError(\"Error writing to eventfd\")\n     \n-    def ack(self, n=1):\n-        buf = c_int64()\n-        eventfd_read(self._fd, buf)\n+    def receive(self, n=1):\n+        buf = c_uint64()\n+        result = eventfd_read(self._fd, byref(buf))\n+        \n+        if result == 0:\n+            return True  # eventfd_read returned success, signal received\n+        elif result == -1:\n+            # if errno is 11 (EAGAIN), this is just because there's no data\n+            # otherwise it's a more serious error\n+            return False\n+        else:\n+            raise OSError(f\"Unexpected return value from eventfd_read: {result}\")\n         \nUnstaged changes after reset:\nM\tquick2wire/eventfd.py\n",
  "diff_2": "diff --git a/quick2wire/eventfd.py b/quick2wire/eventfd.py\nindex 4afcd7f..80685a6 100644\n--- a/quick2wire/eventfd.py\n+++ b/quick2wire/eventfd.py\n@@ -16,8 +16,11 @@ eventfd_write = _libc.eventfd_write\n \n class Semaphore:\n     \"\"\"A Semaphore implemented with eventfd so that it can be used with epoll.\"\"\"\n-    def __init__(self):\n-        self._fd = eventfd(0, EFD_SEMAPHORE)\n+    def __init__(self, blocking=True):\n+        flags = EFD_SEMAPHORE\n+        if not blocking:\n+            flags |= EFD_NONBLOCK\n+        self._fd = eventfd(0, flags)\n     \n     def close(self):\n         os.close(self._fd)\n@@ -28,7 +31,17 @@ class Semaphore:\n     def signal(self, n=1):\n         eventfd_write(self._fd, c_int64(n))\n     \n-    def ack(self, n=1):\n+    def receive(self, n=1):\n         buf = c_int64()\n-        eventfd_read(self._fd, buf)\n+        try:\n+            result = eventfd_read(self._fd, byref(buf))\n+            if result == 0:  # Success\n+                return True\n+            else:\n+                return False\n+        except OSError as e:\n+            if e.args[0] in (11, 35):  # EAGAIN or EWOULDBLOCK (non-blocking with no data available)\n+                return False\n+            raise\n+        return False\n         \nUnstaged changes after reset:\nM\tquick2wire/eventfd.py\n",
  "diff_3": "diff --git a/quick2wire/eventfd.py b/quick2wire/eventfd.py\nindex 4afcd7f..63170f5 100644\n--- a/quick2wire/eventfd.py\n+++ b/quick2wire/eventfd.py\n@@ -1,6 +1,8 @@\n \n from ctypes import *\n import os\n+from errno import EAGAIN\n+from ctypes import get_errno, set_errno\n \n EFD_SEMAPHORE = 1\n EFD_CLOEXEC = 0o2000000\n@@ -13,11 +15,22 @@ eventfd = _libc.eventfd\n eventfd_read = _libc.eventfd_read\n eventfd_write = _libc.eventfd_write\n \n+# Set proper argtypes for the C functions\n+eventfd_read.argtypes = [c_int, POINTER(c_uint64)]\n+eventfd_read.restype = c_int\n \n class Semaphore:\n     \"\"\"A Semaphore implemented with eventfd so that it can be used with epoll.\"\"\"\n-    def __init__(self):\n-        self._fd = eventfd(0, EFD_SEMAPHORE)\n+    def __init__(self, blocking=True):\n+        \"\"\"\n+        Initialize a Semaphore.\n+        \n+        Args:\n+            blocking (bool): If True (default), operations will block. If False, operations return immediately.\n+        \"\"\"\n+        flags = EFD_SEMAPHORE | (0 if blocking else EFD_NONBLOCK)\n+        self._fd = eventfd(0, flags)\n+        self.blocking = blocking\n     \n     def close(self):\n         os.close(self._fd)\n@@ -26,9 +39,31 @@ class Semaphore:\n         return self._fd\n     \n     def signal(self, n=1):\n-        eventfd_write(self._fd, c_int64(n))\n+        eventfd_write(self._fd, eventfd_t(n))\n     \n-    def ack(self, n=1):\n-        buf = c_int64()\n-        eventfd_read(self._fd, buf)\n+    def receive(self):\n+        \"\"\"Try to receive a signal.\n         \n+        Returns:\n+            bool: True if a signal was received, False for non-blocking operations when no signal was available.\n+        \"\"\"\n+        buf = eventfd_t()\n+        try:\n+            set_errno(0)\n+            result = eventfd_read(self._fd, byref(buf))\n+            if result == 0:  # Success\n+                return True\n+            \n+            # Check for nonblocking and would block\n+            if result == -1:\n+                errno_val = get_errno()\n+                if not self.blocking and errno_val == EAGAIN:\n+                    return False\n+                # Otherwise, raise an error\n+                raise OSError(errno_val, os.strerror(errno_val))\n+        except Exception as e:\n+            # In non-blocking mode, a generic exception might be thrown when the call would block\n+            if not self.blocking:\n+                return False\n+            # Re-raise other errors\n+            raise\nUnstaged changes after reset:\nM\tquick2wire/eventfd.py\n",
  "diff_4": "diff --git a/debug b/debug\nnew file mode 100755\nindex 0000000..107a989\nBinary files /dev/null and b/debug differ\ndiff --git a/quick2wire/debug.c b/quick2wire/debug.c\nnew file mode 100644\nindex 0000000..fd17efd\n--- /dev/null\n+++ b/quick2wire/debug.c\n@@ -0,0 +1,28 @@\n+#include <sys/eventfd.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+int main() {\n+    int fd = eventfd(0, EFD_SEMAPHORE | EFD_NONBLOCK);\n+    if (fd == -1) {\n+        perror(\"eventfd\");\n+        exit(1);\n+    }\n+    \n+    uint64_t value;\n+    int ret = eventfd_read(fd, &value);\n+    if (ret == -1) {\n+        if (errno == EAGAIN) {\n+            printf(\"EAGAIN, no data available\\n\");\n+        } else {\n+            perror(\"eventfd_read\");\n+        }\n+    } else {\n+        printf(\"Read value %llu\\n\", value);\n+    }\n+    \n+    close(fd);\n+    return 0;\n+}\ndiff --git a/quick2wire/debug_ctypes.py b/quick2wire/debug_ctypes.py\nnew file mode 100644\nindex 0000000..749d703\n--- /dev/null\n+++ b/quick2wire/debug_ctypes.py\n@@ -0,0 +1,34 @@\n+from ctypes import *\n+import errno\n+import os\n+\n+libc = CDLL(None)\n+\n+# Define all the functions\n+eventfd = libc.eventfd\n+eventfd_read = libc.eventfd_read\n+eventfd_write = libc.eventfd_write\n+\n+# Define the constants\n+EFD_SEMAPHORE = 1\n+EFD_NONBLOCK = 0o4000  # Octal 4000 = 2048 in decimal\n+\n+# Initialize a non-blocking semaphore\n+flags = EFD_SEMAPHORE | EFD_NONBLOCK\n+print(f\"Calling eventfd with flags: {flags}\")\n+fd = eventfd(0, flags)\n+print(f\"Got fd={fd}\")\n+\n+# Try to read from it\n+buf = c_int64(0)\n+try:\n+    print(\"Attempting to read...\")\n+    ret = eventfd_read(fd, byref(buf))\n+    print(f\"eventfd_read returned {ret}\")\n+except OSError as e:\n+    if e.errno == errno.EAGAIN:\n+        print(f\"OSError: {e}, errno={e.errno}, EAGAIN={errno.EAGAIN}\")\n+    else:\n+        print(f\"OSError: {e}\")\n+finally:\n+    os.close(fd)\ndiff --git a/quick2wire/debug_final.py b/quick2wire/debug_final.py\nnew file mode 100644\nindex 0000000..a5f4359\n--- /dev/null\n+++ b/quick2wire/debug_final.py\n@@ -0,0 +1,38 @@\n+#!/usr/bin/env python3\n+import errno\n+from ctypes import cdll, c_int64, c_int, byref, POINTER\n+import os\n+\n+# Load C library\n+libc = cdll.LoadLibrary(None)\n+\n+# Constants\n+EFD_SEMAPHORE = 1\n+EFD_NONBLOCK = 0o4000\n+\n+# Functions\n+eventfd = libc.eventfd\n+eventfd_read = libc.eventfd_read\n+eventfd_write = libc.eventfd_write\n+\n+# Create a non-blocking semaphore\n+flags = EFD_SEMAPHORE | EFD_NONBLOCK\n+print(f\"Creating eventfd with flags {flags}\")\n+fd = eventfd(0, flags)\n+print(f\"Got fd={fd}\")\n+\n+# Try to read from empty semaphore\n+buf = c_int64()\n+ret = eventfd_read(fd, byref(buf))\n+print(f\"eventfd_read returned {ret}\")\n+\n+# Get the error from ctypes\n+__get_errno_location = libc.__errno_location\n+__get_errno_location.restype = POINTER(c_int)\n+err = __get_errno_location().contents.value\n+print(f\"errno = {err}\")\n+print(f\"errno.EAGAIN = {errno.EAGAIN}\")\n+print(f\"Same? {err == errno.EAGAIN}\")\n+\n+# Clean up\n+os.close(fd)\ndiff --git a/quick2wire/eventfd.py b/quick2wire/eventfd.py\nindex 4afcd7f..f6b3c87 100644\n--- a/quick2wire/eventfd.py\n+++ b/quick2wire/eventfd.py\n@@ -1,6 +1,7 @@\n \n from ctypes import *\n import os\n+import errno\n \n EFD_SEMAPHORE = 1\n EFD_CLOEXEC = 0o2000000\n@@ -13,11 +14,19 @@ eventfd = _libc.eventfd\n eventfd_read = _libc.eventfd_read\n eventfd_write = _libc.eventfd_write\n \n+# Setup for error handling\n+_get_errno_location = _libc.__errno_location\n+_get_errno_location.restype = POINTER(c_int)\n+\n \n class Semaphore:\n     \"\"\"A Semaphore implemented with eventfd so that it can be used with epoll.\"\"\"\n-    def __init__(self):\n-        self._fd = eventfd(0, EFD_SEMAPHORE)\n+    def __init__(self, blocking=True):\n+        flags = EFD_SEMAPHORE\n+        if not blocking:\n+            flags |= EFD_NONBLOCK\n+        self._fd = eventfd(0, flags)\n+        self._blocking = blocking\n     \n     def close(self):\n         os.close(self._fd)\n@@ -28,7 +37,15 @@ class Semaphore:\n     def signal(self, n=1):\n         eventfd_write(self._fd, c_int64(n))\n     \n-    def ack(self, n=1):\n+    def receive(self):\n         buf = c_int64()\n-        eventfd_read(self._fd, buf)\n+        ret = eventfd_read(self._fd, byref(buf))\n+        if ret == -1:\n+            err = _get_errno_location().contents.value\n+            \n+            if err == errno.EAGAIN and not self._blocking:\n+                return False  # Non-blocking mode, no data available\n+            else:\n+                raise OSError(err, os.strerror(err))\n+        return True\n         \ndiff --git a/quick2wire/eventfd_debug.py b/quick2wire/eventfd_debug.py\nnew file mode 100644\nindex 0000000..a02eda1\n--- /dev/null\n+++ b/quick2wire/eventfd_debug.py\n@@ -0,0 +1,10 @@\n+#!/usr/bin/env python3\n+import os\n+import errno\n+from quick2wire.eventfd import Semaphore\n+\n+# Test a non-blocking semaphore to debug the issue\n+s = Semaphore(blocking=False)\n+fd = s._fd\n+ret = s.receive()\n+print(f\"Receive returned: {ret}\")\ndiff --git a/quick2wire/flags_debug.py b/quick2wire/flags_debug.py\nnew file mode 100644\nindex 0000000..f12ba15\n--- /dev/null\n+++ b/quick2wire/flags_debug.py\n@@ -0,0 +1,12 @@\n+#!/usr/bin/env python3\n+import quick2wire.eventfd as eventfd\n+\n+# Let's check the flag values\n+print(f\"EFD_SEMAPHORE = {eventfd.EFD_SEMAPHORE}\")\n+print(f\"EFD_NONBLOCK = {eventfd.EFD_NONBLOCK}\")\n+print(f\"Combined flags = {eventfd.EFD_SEMAPHORE | eventfd.EFD_NONBLOCK}\")\n+\n+flags = eventfd.EFD_SEMAPHORE\n+if True:\n+    flags |= eventfd.EFD_NONBLOCK\n+print(f\"Final flags = {flags}\")\nUnstaged changes after reset:\nM\tquick2wire/eventfd.py\n"
}